// --- Breadth-First Search (BFS) Maze Solver (Full Implementation) ---
// A highly technical DSA demonstration in Rapcode. This program finds the
// shortest path from a start (S) to an end (E) in a hardcoded maze.
// It simulates a queue and 2D arrays using only simple variables, resulting
// in extremely verbose but functional code.

// --- Maze Representation (5x5 grid) ---
// 0 = Path, 1 = Wall, 2 = Start, 3 = End
cell_1_1 := 2; cell_1_2 := 0; cell_1_3 := 1; cell_1_4 := 0; cell_1_5 := 0;
cell_2_1 := 1; cell_2_2 := 0; cell_2_3 := 1; cell_2_4 := 0; cell_2_5 := 1;
cell_3_1 := 0; cell_3_2 := 0; cell_3_3 := 0; cell_3_4 := 0; cell_3_5 := 0;
cell_4_1 := 0; cell_4_2 := 1; cell_4_3 := 1; cell_4_4 := 1; cell_4_5 := 1;
cell_5_1 := 0; cell_5_2 := 0; cell_5_3 := 0; cell_5_4 := 3; cell_5_5 := 1;

OUTPUT "Solving the maze with Breadth-First Search..."

// --- Full Initialization of Simulated 2D Arrays ---
// Visited "Array" (0=not visited, 1=visited)
visited_1_1 := 0; visited_1_2 := 0; visited_1_3 := 0; visited_1_4 := 0; visited_1_5 := 0;
visited_2_1 := 0; visited_2_2 := 0; visited_2_3 := 0; visited_2_4 := 0; visited_2_5 := 0;
visited_3_1 := 0; visited_3_2 := 0; visited_3_3 := 0; visited_3_4 := 0; visited_3_5 := 0;
visited_4_1 := 0; visited_4_2 := 0; visited_4_3 := 0; visited_4_4 := 0; visited_4_5 := 0;
visited_5_1 := 0; visited_5_2 := 0; visited_5_3 := 0; visited_5_4 := 0; visited_5_5 := 0;

// Parent "Array" to reconstruct the path later.
parent_x_1_1 := -1; parent_y_1_1 := -1; parent_x_1_2 := -1; parent_y_1_2 := -1; parent_x_1_3 := -1; parent_y_1_3 := -1; parent_x_1_4 := -1; parent_y_1_4 := -1; parent_x_1_5 := -1; parent_y_1_5 := -1;
parent_x_2_1 := -1; parent_y_2_1 := -1; parent_x_2_2 := -1; parent_y_2_2 := -1; parent_x_2_3 := -1; parent_y_2_3 := -1; parent_x_2_4 := -1; parent_y_2_4 := -1; parent_x_2_5 := -1; parent_y_2_5 := -1;
parent_x_3_1 := -1; parent_y_3_1 := -1; parent_x_3_2 := -1; parent_y_3_2 := -1; parent_x_3_3 := -1; parent_y_3_3 := -1; parent_x_3_4 := -1; parent_y_3_4 := -1; parent_x_3_5 := -1; parent_y_3_5 := -1;
parent_x_4_1 := -1; parent_y_4_1 := -1; parent_x_4_2 := -1; parent_y_4_2 := -1; parent_x_4_3 := -1; parent_y_4_3 := -1; parent_x_4_4 := -1; parent_y_4_4 := -1; parent_x_4_5 := -1; parent_y_4_5 := -1;
parent_x_5_1 := -1; parent_y_5_1 := -1; parent_x_5_2 := -1; parent_y_5_2 := -1; parent_x_5_3 := -1; parent_y_5_3 := -1; parent_x_5_4 := -1; parent_y_5_4 := -1; parent_x_5_5 := -1; parent_y_5_5 := -1;

// --- BFS Queue Simulation ---
q_head := 1
q_tail := 1
found := 0
end_x := -1
end_y := -1

// --- BFS Initialization ---
// Add starting coordinates (1,1) to the queue.
q_x_1 := 1
q_y_1 := 1
q_tail := q_tail + 1
visited_1_1 := 1

// --- Main BFS Loop ---
LOOP
IF q_head >= q_tail THEN BREAK ENDIF // Queue is empty
IF found = 1 THEN BREAK ENDIF

// --- Dequeue Current Cell ---
curr_x := 0
curr_y := 0
// This is a manual, verbose way to access q[q_head]
IF q_head = 1 THEN curr_x := q_x_1; curr_y := q_y_1; ENDIF
IF q_head = 2 THEN curr_x := q_x_2; curr_y := q_y_2; ENDIF
IF q_head = 3 THEN curr_x := q_x_3; curr_y := q_y_3; ENDIF
IF q_head = 4 THEN curr_x := q_x_4; curr_y := q_y_4; ENDIF
IF q_head = 5 THEN curr_x := q_x_5; curr_y := q_y_5; ENDIF
// ... this would continue for all 25 queue slots in a larger maze ...
q_head := q_head + 1

OUTPUT "Visiting (" + curr_x + "," + curr_y + ")"

// --- Check All 4 Neighbors ---
neighbor_index := 1
LOOP
    IF neighbor_index > 4 THEN BREAK ENDIF
    
    next_x := curr_x
    next_y := curr_y

    IF neighbor_index = 1 THEN next_y := curr_y - 1 ENDIF // Up
    IF neighbor_index = 2 THEN next_y := curr_y + 1 ENDIF // Down
    IF neighbor_index = 3 THEN next_x := curr_x - 1 ENDIF // Left
    IF neighbor_index = 4 THEN next_x := curr_x + 1 ENDIF // Right

    // --- Check if Neighbor is Valid ---
    is_valid := 0
    IF next_x >= 1 THEN
        IF next_x <= 5 THEN
            IF next_y >= 1 THEN
                IF next_y <= 5 THEN
                    // Bounds check passed. Now get cell and visited status.
                    // This requires a massive lookup structure to simulate a 2D array read.
                    cell_value := -1
                    visited_value := -1
                    IF next_x=1 THEN IF next_y=1 THEN cell_value := cell_1_1; visited_value := visited_1_1; ENDIF ENDIF
                    IF next_x=1 THEN IF next_y=2 THEN cell_value := cell_1_2; visited_value := visited_1_2; ENDIF ENDIF
                    IF next_x=1 THEN IF next_y=3 THEN cell_value := cell_1_3; visited_value := visited_1_3; ENDIF ENDIF
                    IF next_x=1 THEN IF next_y=4 THEN cell_value := cell_1_4; visited_value := visited_1_4; ENDIF ENDIF
                    IF next_x=1 THEN IF next_y=5 THEN cell_value := cell_1_5; visited_value := visited_1_5; ENDIF ENDIF
                    IF next_x=2 THEN IF next_y=1 THEN cell_value := cell_2_1; visited_value := visited_2_1; ENDIF ENDIF
                    IF next_x=2 THEN IF next_y=2 THEN cell_value := cell_2_2; visited_value := visited_2_2; ENDIF ENDIF
                    IF next_x=2 THEN IF next_y=3 THEN cell_value := cell_2_3; visited_value := visited_2_3; ENDIF ENDIF
                    IF next_x=2 THEN IF next_y=4 THEN cell_value := cell_2_4; visited_value := visited_2_4; ENDIF ENDIF
                    IF next_x=2 THEN IF next_y=5 THEN cell_value := cell_2_5; visited_value := visited_2_5; ENDIF ENDIF
                    IF next_x=3 THEN IF next_y=1 THEN cell_value := cell_3_1; visited_value := visited_3_1; ENDIF ENDIF
                    IF next_x=3 THEN IF next_y=2 THEN cell_value := cell_3_2; visited_value := visited_3_2; ENDIF ENDIF
                    IF next_x=3 THEN IF next_y=3 THEN cell_value := cell_3_3; visited_value := visited_3_3; ENDIF ENDIF
                    IF next_x=3 THEN IF next_y=4 THEN cell_value := cell_3_4; visited_value := visited_3_4; ENDIF ENDIF
                    IF next_x=3 THEN IF next_y=5 THEN cell_value := cell_3_5; visited_value := visited_3_5; ENDIF ENDIF
                    IF next_x=4 THEN IF next_y=1 THEN cell_value := cell_4_1; visited_value := visited_4_1; ENDIF ENDIF
                    IF next_x=4 THEN IF next_y=2 THEN cell_value := cell_4_2; visited_value := visited_4_2; ENDIF ENDIF
                    IF next_x=4 THEN IF next_y=3 THEN cell_value := cell_4_3; visited_value := visited_4_3; ENDIF ENDIF
                    IF next_x=4 THEN IF next_y=4 THEN cell_value := cell_4_4; visited_value := visited_4_4; ENDIF ENDIF
                    IF next_x=4 THEN IF next_y=5 THEN cell_value := cell_4_5; visited_value := visited_4_5; ENDIF ENDIF
                    IF next_x=5 THEN IF next_y=1 THEN cell_value := cell_5_1; visited_value := visited_5_1; ENDIF ENDIF
                    IF next_x=5 THEN IF next_y=2 THEN cell_value := cell_5_2; visited_value := visited_5_2; ENDIF ENDIF
                    IF next_x=5 THEN IF next_y=3 THEN cell_value := cell_5_3; visited_value := visited_5_3; ENDIF ENDIF
                    IF next_x=5 THEN IF next_y=4 THEN cell_value := cell_5_4; visited_value := visited_5_4; ENDIF ENDIF
                    IF next_x=5 THEN IF next_y=5 THEN cell_value := cell_5_5; visited_value := visited_5_5; ENDIF ENDIF
                    
                    // Check if not a wall and not visited
                    IF cell_value != 1 THEN
                        IF visited_value = 0 THEN
                            is_valid := 1
                        ENDIF
                    ENDIF
                ENDIF
            ENDIF
        ENDIF
    ENDIF

    IF is_valid = 1 THEN
        OUTPUT "  -> Found valid neighbor: (" + next_x + "," + next_y + ")"
        
        // --- Update Visited and Parent (Simulated 2D array write) ---
        IF next_x=1 THEN IF next_y=1 THEN visited_1_1 := 1; parent_x_1_1 := curr_x; parent_y_1_1 := curr_y; ENDIF ENDIF
        IF next_x=1 THEN IF next_y=2 THEN visited_1_2 := 1; parent_x_1_2 := curr_x; parent_y_1_2 := curr_y; ENDIF ENDIF
        IF next_x=1 THEN IF next_y=3 THEN visited_1_3 := 1; parent_x_1_3 := curr_x; parent_y_1_3 := curr_y; ENDIF ENDIF
        IF next_x=1 THEN IF next_y=4 THEN visited_1_4 := 1; parent_x_1_4 := curr_x; parent_y_1_4 := curr_y; ENDIF ENDIF
        IF next_x=1 THEN IF next_y=5 THEN visited_1_5 := 1; parent_x_1_5 := curr_x; parent_y_1_5 := curr_y; ENDIF ENDIF
        IF next_x=2 THEN IF next_y=1 THEN visited_2_1 := 1; parent_x_2_1 := curr_x; parent_y_2_1 := curr_y; ENDIF ENDIF
        IF next_x=2 THEN IF next_y=2 THEN visited_2_2 := 1; parent_x_2_2 := curr_x; parent_y_2_2 := curr_y; ENDIF ENDIF
        IF next_x=2 THEN IF next_y=3 THEN visited_2_3 := 1; parent_x_2_3 := curr_x; parent_y_2_3 := curr_y; ENDIF ENDIF
        IF next_x=2 THEN IF next_y=4 THEN visited_2_4 := 1; parent_x_2_4 := curr_x; parent_y_2_4 := curr_y; ENDIF ENDIF
        IF next_x=2 THEN IF next_y=5 THEN visited_2_5 := 1; parent_x_2_5 := curr_x; parent_y_2_5 := curr_y; ENDIF ENDIF
        IF next_x=3 THEN IF next_y=1 THEN visited_3_1 := 1; parent_x_3_1 := curr_x; parent_y_3_1 := curr_y; ENDIF ENDIF
        IF next_x=3 THEN IF next_y=2 THEN visited_3_2 := 1; parent_x_3_2 := curr_x; parent_y_3_2 := curr_y; ENDIF ENDIF
        IF next_x=3 THEN IF next_y=3 THEN visited_3_3 := 1; parent_x_3_3 := curr_x; parent_y_3_3 := curr_y; ENDIF ENDIF
        IF next_x=3 THEN IF next_y=4 THEN visited_3_4 := 1; parent_x_3_4 := curr_x; parent_y_3_4 := curr_y; ENDIF ENDIF
        IF next_x=3 THEN IF next_y=5 THEN visited_3_5 := 1; parent_x_3_5 := curr_x; parent_y_3_5 := curr_y; ENDIF ENDIF
        IF next_x=4 THEN IF next_y=1 THEN visited_4_1 := 1; parent_x_4_1 := curr_x; parent_y_4_1 := curr_y; ENDIF ENDIF
        IF next_x=4 THEN IF next_y=2 THEN visited_4_2 := 1; parent_x_4_2 := curr_x; parent_y_4_2 := curr_y; ENDIF ENDIF
        IF next_x=4 THEN IF next_y=3 THEN visited_4_3 := 1; parent_x_4_3 := curr_x; parent_y_4_3 := curr_y; ENDIF ENDIF
        IF next_x=4 THEN IF next_y=4 THEN visited_4_4 := 1; parent_x_4_4 := curr_x; parent_y_4_4 := curr_y; ENDIF ENDIF
        IF next_x=4 THEN IF next_y=5 THEN visited_4_5 := 1; parent_x_4_5 := curr_x; parent_y_4_5 := curr_y; ENDIF ENDIF
        IF next_x=5 THEN IF next_y=1 THEN visited_5_1 := 1; parent_x_5_1 := curr_x; parent_y_5_1 := curr_y; ENDIF ENDIF
        IF next_x=5 THEN IF next_y=2 THEN visited_5_2 := 1; parent_x_5_2 := curr_x; parent_y_5_2 := curr_y; ENDIF ENDIF
        IF next_x=5 THEN IF next_y=3 THEN visited_5_3 := 1; parent_x_5_3 := curr_x; parent_y_5_3 := curr_y; ENDIF ENDIF
        IF next_x=5 THEN IF next_y=4 THEN visited_5_4 := 1; parent_x_5_4 := curr_x; parent_y_5_4 := curr_y; ENDIF ENDIF
        IF next_x=5 THEN IF next_y=5 THEN visited_5_5 := 1; parent_x_5_5 := curr_x; parent_y_5_5 := curr_y; ENDIF ENDIF

        // --- Enqueue Neighbor ---
        IF q_tail = 1 THEN q_x_1 := next_x; q_y_1 := next_y; ENDIF
        IF q_tail = 2 THEN q_x_2 := next_x; q_y_2 := next_y; ENDIF
        IF q_tail = 3 THEN q_x_3 := next_x; q_y_3 := next_y; ENDIF
        IF q_tail = 4 THEN q_x_4 := next_x; q_y_4 := next_y; ENDIF
        IF q_tail = 5 THEN q_x_5 := next_x; q_y_5 := next_y; ENDIF
        // ... this would continue for all 25 queue slots ...
        q_tail := q_tail + 1
        
        // --- Check if the neighbor is the end ---
        IF cell_value = 3 THEN
            found := 1
            end_x := next_x
            end_y := next_y
        ENDIF
    ENDIF
    
    neighbor_index := neighbor_index + 1
ENDLOOP

ENDLOOP

// --- Path Reconstruction ---
IF found = 1 THEN
OUTPUT "Path found! Reconstructing..."

// Build path in reverse using a simulated stack
path_len := 0
path_x := end_x
path_y := end_y

LOOP
    IF path_x = -1 THEN BREAK ENDIF
    path_len := path_len + 1
    // Manual stack push
    IF path_len = 1 THEN path_x_1 := path_x; path_y_1 := path_y; ENDIF
    IF path_len = 2 THEN path_x_2 := path_x; path_y_2 := path_y; ENDIF
    IF path_len = 3 THEN path_x_3 := path_x; path_y_3 := path_y; ENDIF
    IF path_len = 4 THEN path_x_4 := path_x; path_y_4 := path_y; ENDIF
    IF path_len = 5 THEN path_x_5 := path_x; path_y_5 := path_y; ENDIF
    IF path_len = 6 THEN path_x_6 := path_x; path_y_6 := path_y; ENDIF
    IF path_len = 7 THEN path_x_7 := path_x; path_y_7 := path_y; ENDIF
    IF path_len = 8 THEN path_x_8 := path_x; path_y_8 := path_y; ENDIF
    IF path_len = 9 THEN path_x_9 := path_x; path_y_9 := path_y; ENDIF
    IF path_len = 10 THEN path_x_10 := path_x; path_y_10 := path_y; ENDIF
    // ... would continue for max path length ...
    
    // Get parent coords using another massive lookup
    parent_x := -1
    parent_y := -1
    IF path_x=1 THEN IF path_y=1 THEN parent_x := parent_x_1_1; parent_y := parent_y_1_1; ENDIF ENDIF
    IF path_x=1 THEN IF path_y=2 THEN parent_x := parent_x_1_2; parent_y := parent_y_1_2; ENDIF ENDIF
    IF path_x=1 THEN IF path_y=3 THEN parent_x := parent_x_1_3; parent_y := parent_y_1_3; ENDIF ENDIF
    IF path_x=1 THEN IF path_y=4 THEN parent_x := parent_x_1_4; parent_y := parent_y_1_4; ENDIF ENDIF
    IF path_x=1 THEN IF path_y=5 THEN parent_x := parent_x_1_5; parent_y := parent_y_1_5; ENDIF ENDIF
    IF path_x=2 THEN IF path_y=1 THEN parent_x := parent_x_2_1; parent_y := parent_y_2_1; ENDIF ENDIF
    IF path_x=2 THEN IF path_y=2 THEN parent_x := parent_x_2_2; parent_y := parent_y_2_2; ENDIF ENDIF
    IF path_x=2 THEN IF path_y=3 THEN parent_x := parent_x_2_3; parent_y := parent_y_2_3; ENDIF ENDIF
    IF path_x=2 THEN IF path_y=4 THEN parent_x := parent_x_2_4; parent_y := parent_y_2_4; ENDIF ENDIF
    IF path_x=2 THEN IF path_y=5 THEN parent_x := parent_x_2_5; parent_y := parent_y_2_5; ENDIF ENDIF
    IF path_x=3 THEN IF path_y=1 THEN parent_x := parent_x_3_1; parent_y := parent_y_3_1; ENDIF ENDIF
    IF path_x=3 THEN IF path_y=2 THEN parent_x := parent_x_3_2; parent_y := parent_y_3_2; ENDIF ENDIF
    IF path_x=3 THEN IF path_y=3 THEN parent_x := parent_x_3_3; parent_y := parent_y_3_3; ENDIF ENDIF
    IF path_x=3 THEN IF path_y=4 THEN parent_x := parent_x_3_4; parent_y := parent_y_3_4; ENDIF ENDIF
    IF path_x=3 THEN IF path_y=5 THEN parent_x := parent_x_3_5; parent_y := parent_y_3_5; ENDIF ENDIF
    IF path_x=4 THEN IF path_y=1 THEN parent_x := parent_x_4_1; parent_y := parent_y_4_1; ENDIF ENDIF
    IF path_x=4 THEN IF path_y=2 THEN parent_x := parent_x_4_2; parent_y := parent_y_4_2; ENDIF ENDIF
    IF path_x=4 THEN IF path_y=3 THEN parent_x := parent_x_4_3; parent_y := parent_y_4_3; ENDIF ENDIF
    IF path_x=4 THEN IF path_y=4 THEN parent_x := parent_x_4_4; parent_y := parent_y_4_4; ENDIF ENDIF
    IF path_x=4 THEN IF path_y=5 THEN parent_x := parent_x_4_5; parent_y := parent_y_4_5; ENDIF ENDIF
    IF path_x=5 THEN IF path_y=1 THEN parent_x := parent_x_5_1; parent_y := parent_y_5_1; ENDIF ENDIF
    IF path_x=5 THEN IF path_y=2 THEN parent_x := parent_x_5_2; parent_y := parent_y_5_2; ENDIF ENDIF
    IF path_x=5 THEN IF path_y=3 THEN parent_x := parent_x_5_3; parent_y := parent_y_5_3; ENDIF ENDIF
    IF path_x=5 THEN IF path_y=4 THEN parent_x := parent_x_5_4; parent_y := parent_y_5_4; ENDIF ENDIF
    IF path_x=5 THEN IF path_y=5 THEN parent_x := parent_x_5_5; parent_y := parent_y_5_5; ENDIF ENDIF

    path_x := parent_x
    path_y := parent_y
ENDLOOP

// Print path in correct order (pop from stack)
OUTPUT "Shortest path from Start to End:"
LOOP
    IF path_len < 1 THEN BREAK ENDIF
    // Manual stack pop
    IF path_len = 1 THEN path_x := path_x_1; path_y := path_y_1; ENDIF
    IF path_len = 2 THEN path_x := path_x_2; path_y := path_y_2; ENDIF
    IF path_len = 3 THEN path_x := path_x_3; path_y := path_y_3; ENDIF
    IF path_len = 4 THEN path_x := path_x_4; path_y := path_y_4; ENDIF
    IF path_len = 5 THEN path_x := path_x_5; path_y := path_y_5; ENDIF
    IF path_len = 6 THEN path_x := path_x_6; path_y := path_y_6; ENDIF
    IF path_len = 7 THEN path_x := path_x_7; path_y := path_y_7; ENDIF
    IF path_len = 8 THEN path_x := path_x_8; path_y := path_y_8; ENDIF
    IF path_len = 9 THEN path_x := path_x_9; path_y := path_y_9; ENDIF
    IF path_len = 10 THEN path_x := path_x_10; path_y := path_y_10; ENDIF
    // ... would continue for max path length ...
    
    OUTPUT " -> (" + path_x + "," + path_y + ")"
    path_len := path_len - 1
ENDLOOP

ELSE
OUTPUT "Search complete. No path found."
ENDIF