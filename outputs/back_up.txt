import json
import re
import xml.etree.ElementTree as ET

# Namespaces used in the Raptor XML file
# These are essential for finding elements with ET.find()
NAMESPACES = {
    '': 'http://schemas.datacontract.org/2004/07/RAPTOR_Avalonia_MVVM.ViewModels',
    'i': 'http://www.w3.org/2001/XMLSchema-instance',
    'a': 'http://schemas.datacontract.org/2004/07/raptor',
    'b': 'http://www.w3.org/2001/XMLSchema'
}

def get_node_type(xml_node):
    """
    Determines the component's semantic type, preferring the i:type attribute
    over the plain XML tag name. This handles Raptor's polymorphism.
    """
    if xml_node is None:
        return None
    
    # The 'type' attribute is in the 'i' namespace (XMLSchema-instance)
    type_attr = xml_node.get(f"{{{NAMESPACES['i']}}}type")
    
    if type_attr:
        # The attribute value is like "a:Rectangle", we just want "Rectangle"
        return type_attr.split(':')[-1]
        
    # Fallback to the tag name if i:type is not present
    return xml_node.tag.split('}')[-1]

def find_element_robust(xml_node, tag):
    """
    A robust find function that handles local namespace overrides (xmlns="").
    It first tries to find the tag with the namespace and falls back to searching
    for the local name without a namespace.
    """
    if xml_node is None:
        return None
    
    # Try finding with the full namespace prefix (e.g., 'a:_Successor')
    element = xml_node.find(tag, NAMESPACES)
    
    if element is None:
        # Fallback: find by local name for elements in a reset namespace (xmlns="")
        local_tag = tag.split(':')[-1]
        element = xml_node.find(local_tag)
        
    return element

def safe_get_text(xml_node, tag, default=''):
    """
    Safely finds an element using the robust finder and gets its text,
    returning a default if not found.
    """
    element = find_element_robust(xml_node, tag)
    if element is not None and element.text is not None:
        return element.text
    return default

def find_actual_component(container_element):
    """
    Finds the actual component node.
    Raptor XML can place the component as a child of a container (e.g., _Successor)
    or define the container itself as the component using i:type. This handles both.
    """
    if container_element is None:
        return None
    
    # Case 1: The container itself is the component (e.g., <_Successor i:type="a:Rectangle">)
    if container_element.get(f"{{{NAMESPACES['i']}}}type"):
        return container_element
    
    # Case 2: The component is the first child of the container.
    # Iterate through children to find the first actual element.
    for child in container_element:
        if isinstance(child.tag, str): # Filters out comments, etc.
            return child
    return None


def parse_literal(value_str):
    """
    Parses a string value and converts it to a Python literal (int, float, bool, or str).
    Returns a dictionary representing the AST Literal node.
    """
    value_str = value_str.strip()
    if value_str.lower() == 'true':
        return {"type": "Literal", "value": True}
    if value_str.lower() == 'false':
        return {"type": "Literal", "value": False}
    if value_str.startswith('"') and value_str.endswith('"'):
        return {"type": "Literal", "value": value_str[1:-1]}
    try:
        return {"type": "Literal", "value": int(value_str)}
    except ValueError:
        try:
            return {"type": "Literal", "value": float(value_str)}
        except ValueError:
            return {"type": "Identifier", "name": value_str}

def parse_expression(expr_str):
    """
    Parses a string expression (e.g., "x + 5", "greedy != true") into an AST node.
    Handles simple binary expressions and literals/identifiers.
    """
    expr_str = expr_str.strip()

    string_parts = re.split(r' \+ ', expr_str)
    if len(string_parts) > 1 and any(p.startswith('"') for p in string_parts):
        ast = parse_expression(string_parts[0])
        for part in string_parts[1:]:
            ast = {
                "type": "BinaryExpression",
                "operator": "+",
                "left": ast,
                "right": parse_expression(part)
            }
        return ast
        
    operators = ['!=', '<=', '>=', '==', '=', '<', '>', ':=', '+', '-', '*', '/']
    for op in operators:
        parts = expr_str.split(op, 1)
        if len(parts) == 2:
            ast_op = op
            if op == ':=':
                ast_op = "="
            elif op == '=':
                ast_op = "=="

            return {
                "type": "BinaryExpression",
                "operator": ast_op,
                "left": parse_expression(parts[0]),
                "right": parse_expression(parts[1])
            }
    
    return parse_literal(expr_str)


def parse_node(xml_node):
    """
    Recursively parses a single XML node and its successors into a list of AST nodes.
    """
    if xml_node is None or xml_node.get(f"{{{NAMESPACES['i']}}}nil") == 'true':
        return []

    node_type = get_node_type(xml_node)
    ast_nodes = []
    current_ast_node = None

    if node_type == 'Rectangle':
        text = safe_get_text(xml_node, 'a:_text_str')
        if ':=' in text:
            left, right = text.split(':=', 1)
            current_ast_node = {
                "type": "AssignmentStatement",
                "left": parse_expression(left.strip()),
                "right": parse_expression(right.strip())
            }
        else:
            print(f"Warning: Unhandled Rectangle content: {text}")

    elif node_type == 'Parallelogram':
        is_input = safe_get_text(xml_node, 'a:_is_input', 'false').lower() == 'true'
        text_str = safe_get_text(xml_node, 'a:_text_str')
        
        if is_input:
            prompt_text = safe_get_text(xml_node, 'a:_prompt')
            current_ast_node = {
                "type": "AssignmentStatement",
                "left": {"type": "Identifier", "name": text_str.strip()},
                "right": { "type": "CallExpression", "callee": "Input", "prompt": prompt_text }
            }
        else:
            current_ast_node = {
                "type": "ExpressionStatement",
                "expression": {
                    "type": "CallExpression",
                    "callee": "Output",
                    "arguments": [parse_expression(text_str)]
                }
            }
            
    elif node_type == 'IF_Control':
        text = safe_get_text(xml_node, 'a:_text_str')
        left_child_container = find_element_robust(xml_node, 'a:_left_Child')
        right_child_container = find_element_robust(xml_node, 'a:_right_Child')
        
        current_ast_node = {
            "type": "IfStatement",
            "test": parse_expression(text),
            "consequent": { "type": "BlockStatement", "body": parse_node(find_actual_component(left_child_container)) },
            "alternate": { "type": "BlockStatement", "body": parse_node(find_actual_component(right_child_container)) }
        }
        
    elif node_type == 'Loop':
        text = safe_get_text(xml_node, 'a:_text_str')
        before_child_container = find_element_robust(xml_node, 'a:_before_Child')
        after_child_container = find_element_robust(xml_node, 'a:_after_Child')
        
        loop_body = parse_node(find_actual_component(before_child_container)) + parse_node(find_actual_component(after_child_container))

        current_ast_node = {
            "type": "DoWhileLoop",
            "test": parse_expression(text),
            "body": { "type": "BlockStatement", "body": loop_body }
        }

    if current_ast_node:
        ast_nodes.append(current_ast_node)

    successor_container = find_element_robust(xml_node, 'a:_Successor')
    successor_node = find_actual_component(successor_container)
    if successor_node is not None:
        ast_nodes.extend(parse_node(successor_node))
    
    return ast_nodes


def convert_raptor_to_ast(xml_file_path):
    """
    Main function to load a Raptor XML file and convert it to a JSON AST.
    """
    try:
        tree = ET.parse(xml_file_path)
        root = tree.getroot()

        start_node = root.find('.//a:Start', NAMESPACES)
        if start_node is None:
            return {"error": "Could not find the <Start> node in the XML file."}

        successor_container = find_element_robust(start_node, 'a:_Successor')
        first_node = find_actual_component(successor_container)

        body = parse_node(first_node)
        
        program_ast = { "type": "Program", "body": body }
        return program_ast

    except ET.ParseError as e:
        return {"error": f"XML Parse Error: {e}"}
    except FileNotFoundError:
        return {"error": f"File not found: {xml_file_path}"}
    except Exception as e:
        return {"error": f"An unexpected error occurred: {e}", "details": str(e)}


if __name__ == '__main__':
    xml_file = 'area.rap' 
    output_json_file = 'flowchart.json'
    
    try:
        with open(xml_file, 'r', encoding='utf-8') as f:
            pass
    except FileNotFoundError:
        print(f"'{xml_file}' not found. Please save the Raptor XML content to this file.")
        exit()
        
    ast_representation = convert_raptor_to_ast(xml_file)

    # Write the output to flowchart.json
    with open(output_json_file, 'w', encoding='utf-8') as f:
        json.dump(ast_representation, f, indent=2)
    
    print(f"AST has been successfully generated and saved to '{output_json_file}'.")


import json
import os

def generate_f_string_from_concat(node):
    """
    Takes a nested BinaryExpression node for string concatenation and
    flattens it into a Python f-string.
    """
    parts = []
    
    def collect_parts(n):
        # Recursively dive into the left and right sides of the '+' operator
        if n.get("type") == "BinaryExpression" and n.get("operator") == "+":
            collect_parts(n.get("left"))
            collect_parts(n.get("right"))
        # If we find a string literal, add its content directly
        elif n.get("type") == "Literal" and isinstance(n.get("value"), str):
            # Escape any existing curly braces in the literal text
            parts.append(n.get("value").replace("{", "{{").replace("}", "}}"))
        # If we find a variable or number, embed it in braces for the f-string
        else:
            expression_code = generate_expression_string(n, is_top_level=True)
            parts.append(f"{{{expression_code}}}")

    collect_parts(node)
    return f'f"{"".join(parts)}"'

def generate_expression_string(node, is_top_level=False):
    """
    Recursively builds a code string from an expression AST node.
    `is_top_level` helps remove unnecessary outer parentheses.
    """
    if node is None:
        return ""
        
    node_type = node.get("type")
    
    if node_type == "Literal":
        value = node.get("value")
        if isinstance(value, str):
            return f'"{value}"'
        return str(value)
        
    elif node_type == "Identifier":
        return node.get("name", "")
        
    elif node_type == "BinaryExpression":
        left = generate_expression_string(node.get("left"))
        right = generate_expression_string(node.get("right"))
        operator = node.get("operator", "")
        
        expression_str = f"{left} {operator} {right}"
        
        return expression_str if is_top_level else f"({expression_str})"

    elif node_type == "CallExpression":
        callee = node.get("callee")
        if callee == "Input":
            prompt_literal = node.get("prompt", "")
            # Strip outer quotes from the prompt if they exist, as they are part of the XML text
            if len(prompt_literal) >= 2 and prompt_literal.startswith('"') and prompt_literal.endswith('"'):
                prompt_literal = prompt_literal[1:-1]
            return f'input("{prompt_literal}")'
        
        return "call_expression()"
        
    return ""

def generate_code_from_ast(ast_nodes, indent_level=0):
    """
    Recursively traverses the AST and generates formatted, Pythonic code lines.
    """
    code_lines = []
    indent = "    " * indent_level

    for node in ast_nodes:
        node_type = node.get("type")

        if node_type == "AssignmentStatement":
            left = generate_expression_string(node.get("left"), is_top_level=True)
            right_node = node.get("right")
            right = generate_expression_string(right_node, is_top_level=True)

            # Heuristic: Cast input to int, as Raptor often uses it for numbers.
            if right_node.get("type") == "CallExpression" and right_node.get("callee") == "Input":
                right = f"int({right})"
            
            code_lines.append(f"{indent}{left} = {right}")
            
        elif node_type == "ExpressionStatement":
            expression = node.get("expression", {})
            if expression.get("callee") == "Output":
                arg_node = expression.get("arguments", [])[0]
                # If the output is a string concatenation, generate a clean f-string.
                if arg_node.get("type") == "BinaryExpression" and arg_node.get("operator") == "+":
                    arg_string = generate_f_string_from_concat(arg_node)
                else:
                    arg_string = generate_expression_string(arg_node, is_top_level=True)
                code_lines.append(f"{indent}print({arg_string})")
                
        elif node_type == "IfStatement":
            consequent = node.get("consequent", {}).get("body", [])
            alternate = node.get("alternate", {}).get("body", [])
            
            # Pattern recognition: Simplify 'if condition: x=True else: x=False' to 'x = condition'
            is_bool_assignment = (
                len(consequent) == 1 and len(alternate) == 1 and
                consequent[0].get("type") == "AssignmentStatement" and
                alternate[0].get("type") == "AssignmentStatement" and
                consequent[0].get("left").get("name") == alternate[0].get("left").get("name") and
                consequent[0].get("right").get("value") is True and
                alternate[0].get("right").get("value") is False
            )
            
            if is_bool_assignment:
                var_name = consequent[0].get("left").get("name")
                test_expr = generate_expression_string(node.get("test"), is_top_level=True)
                code_lines.append(f"{indent}{var_name} = ({test_expr})")
                continue

            # Default if/else generation
            test = generate_expression_string(node.get("test"), is_top_level=True)
            code_lines.append(f"{indent}if {test}:")
            
            if not consequent:
                code_lines.append(f"{indent}    pass")
            else:
                code_lines.extend(generate_code_from_ast(consequent, indent_level + 1))
            
            if alternate:
                code_lines.append(f"{indent}else:")
                code_lines.extend(generate_code_from_ast(alternate, indent_level + 1))

        elif node_type == "DoWhileLoop":
            test_expression = generate_expression_string(node.get("test"), is_top_level=True)
            body_nodes = node.get("body", {}).get("body", [])

            # Heuristic to detect Raptor's input validation loop pattern.
            # This pattern has an input (_before_Child) and an error message (_after_Child).
            is_validation_loop = (
                len(body_nodes) == 2 and
                body_nodes[0].get("type") == "AssignmentStatement" and
                body_nodes[0].get("right", {}).get("callee") == "Input" and
                body_nodes[1].get("type") == "ExpressionStatement" and
                body_nodes[1].get("expression", {}).get("callee") == "Output"
            )

            if is_validation_loop:
                # Special handling for validation loops to print the error message conditionally.
                input_code_line = generate_code_from_ast([body_nodes[0]], 0)[0]
                error_code_line = generate_code_from_ast([body_nodes[1]], 0)[0]

                code_lines.append(f"{indent}while True:")
                code_lines.append(f"{indent}    {input_code_line}")
                code_lines.append(f"{indent}    if {test_expression}:")
                code_lines.append(f"{indent}        break")
                code_lines.append(f"{indent}    {error_code_line}")

            else:
                # Standard post-test loop logic where the test is the EXIT condition.
                code_lines.append(f"{indent}while True:")
                code_lines.extend(generate_code_from_ast(body_nodes, indent_level + 1))
                code_lines.append(f"{indent}    if {test_expression}:")
                code_lines.append(f"{indent}        break")
            
        elif node_type == "BlockStatement":
            code_lines.extend(generate_code_from_ast(node.get("body", []), indent_level))

    return code_lines

def main():
    """
    Main function to read the AST, generate code, and save it to a file.
    """
    input_json_file = 'flowchart.json'
    output_code_file = 'generated_code.py'

    if not os.path.exists(input_json_file):
        print(f"Error: Input file '{input_json_file}' not found.")
        print("Please run the 'raptor_to_ast.py' script first.")
        return

    with open(input_json_file, 'r', encoding='utf-8') as f:
        ast_data = json.load(f)

    if "error" in ast_data:
        print(f"The AST file contains an error: {ast_data['error']}")
        return

    program_body = ast_data.get("body", [])
    generated_code = generate_code_from_ast(program_body)

    with open(output_code_file, 'w', encoding='utf-8') as f:
        f.write("# This code was auto-generated from a Raptor flowchart AST.\n")
        f.write("# It has been cleaned up to be more Pythonic and runnable.\n\n")
        f.write("\n".join(generated_code))
        
    print(f"Code has been successfully generated and saved to '{output_code_file}'.")

if __name__ == '__main__':
    main()

